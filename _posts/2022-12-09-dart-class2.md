---
title:  "Class 와 객체지향 프로그래밍(2)"  
date:   2022-12-09 16:10:09 +0900
categories: [Flutter, dart]
tag: [class, , ]
toc: true
---

### Implicit interfaces (함축적 인터페이스)

모든 클래스는 클래스와 클래스가 구현하는 모든 인터페이스의 모든 인스턴스 멤버를 포함하는 인터페이스를 함축적으로 정의한다. B 클래스의 구현을 상속받지 않고 클래스 B의 API를 지원하는 클래스 A를 생성하려면 클래스 A가 B 인터페이스를 구현해야 한다.

클래스는 구현절 안에서 선언한 다음 인터페이스에 필요한 API를 제공하여 하나 이상의 인터페이스를 구현한다. 예를 들어:

``` dart
// A person. The implicit interface contains greet().
class Person {
  // In the interface, but visible only in this library.
  final String _name;

  // Not in the interface, since this is a constructor.
  Person(this._name);

  // In the interface.
  String greet(String who) => 'Hello, $who. I am $_name.';
}

// An implementation of the Person interface.
class Impostor implements Person {
  String get _name => '';

  String greet(String who) => 'Hi $who. Do you know who I am?';
}

String greetBob(Person person) => person.greet('Bob');

void main() {
  print(greetBob(Person('Kathy')));
  print(greetBob(Impostor()));
}
```

다음은 클래스가 여러 인터페이스를 구현하도록 지정하는 예이다.

``` dart
class Point implements Comparable, Location {...}
```

- #### 클라스의 확장(Extending a class)

서브클래스를 생성하려면 __extends__ 를 사용하며  __super__ 는 상위(부모)클래스를 참조한다.

``` dart
class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
  // ···
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
  // ···
}

```
확장의 다른 사용법에 대해서는 제네릭의 매개변수화된 유형에 대한 설명을 참조한다.

- #### 멤버의 재 정의 (Overriding members)
서브클래스는 인스턴스 메서드(연산자 포함), getter 및 setter를 재정의할 수 있다. __@override__ 주석을 사용하여 의도적으로 멤버를 재정의하고 있음을 나타낼 수 있다.

``` dart
class Television {
  // ···
  set contrast(int value) {...}
}

class SmartTelevision extends Television {
  @override
  set contrast(num value) {...}
  // ···
}

```
재정의 메서드 선언은 아래와 같이 여러 가지 면에서 재정의된 메서드와 일치해야 합니다.

- 반환 유형은 재정의된 메서드의 반환 유형과 동일한 유형(또는 하위 유형)이어야 한다.
- 인수 유형은 재정의된 메서드의 인수 유형과 동일한 유형(또는 상위 유형)이어야 합니다. 앞의 예에서 SmartTelevision의 __constrast__ 세터(setter)는 인수 유형을 int에서 상위 유형인 num으로 변경하고 있다.
- 재정의된 메서드가 n 위치 매개변수를 허용하는 경우 재정의 메서드는 n 위치 매개변수도 허용해야 한다.
- 제네릭 메서드는 제네릭이 아닌 메서드를 재정의할 수 없고 제네릭이 아닌 메서드는 제네릭 메서드를 재정의할 수 없다.

떄로는 메소드 매개변수 또는 인스턴스 변수의 type을 축소하고 싶을 수 있다. 이것은 정상적인 규칙을 위반하고 런타임 시에 type 오류를 일으킬 수 있다는 점에서 다운캐스트(?)와 유사하다. 그래도 코드가 type  오류가 발생하지 않는다는 것을 보장할 수 있다면 유형을 좁힐 수 있다. 이 경우 매개 변수 선언에서  __covariant__ 키워드를 사용할 수 있습다. 자세한 내용은 Dart 언어 규격을 참조한다.

- 주의 : == 를 재정의하면 객체의 해시코드 게터(hashCode getter) 도 재정의해야 한다. == 및 hashCode 재정의의 예는 맵 키 구현을 참조한다. 

- #### noSuchMethod()

코드가 존재하지 않는 메서드나 인스턴스 변수를 사용하려고 시도할 때마다 이를 알아내서 대응하려면 noSuchMethod()를 재정의할 수 있다.

``` dart
class A {
  // Unless you override noSuchMethod, using a
  // non-existent member results in a NoSuchMethodError.
  @override
  void noSuchMethod(Invocation invocation) {
    print('You tried to use a non-existent member: '
        '${invocation.memberName}');
  }
}

```
다음 중 하나에 해당하지 않는 한 구현되지 않은 메서드를 호출할 수 없다.

- 수신자에 static type 인 dynamic이 있다.
- 수신자는 구현되지 않은 메서드(추상은 OK)를 정의하는 정적 유형을 가지며 수신자의  dynamic type은 클라스 내부의 어떤 하나와는 다른 noSuchMethod() 구현을 갖는다 .(?)
자세한 내용은 비공식 noSuchMethod 전달 사양을 참조하자.

- ### 확장 메서드 (Extension methods)

확장 메서드는 기존 라이브러리에 기능을 추가하는 방법다. 모르는 사이에 확장 메서드을 사용할 수도 있다. 예를 들어 IDE에서 __코드완성__ 을 사용하면 일반 방법들과  함께 확장 메서드를 제안한다.

다음은 string_apis.dart에 정의된 parseInt()라는이름의 확장 메서드를 사용하는 예입니다.

``` dart

import 'string_apis.dart';
...
print('42'.padLeft(5)); // Use a String method.
print('42'.parseInt()); // Use an extension method.

```
확장 메서드 사용 및 구현에 대한 자세한 내용은 extension methods page를 참조하자.

- #### Enumerated types

종종 enumerations or enums 라고도 불리는 열거형(Enumerated types)은 고정된 수의 상수 값을 나타내는 데 사용되는 특별한 종류의 클래스다.

- 주의 : 모든 enum은 자동으로 Enum 클래스를 확장다. 그들은 또한 봉인(sealed)되어 있어서 서브클래싱, 구현, 혼합 또는 명시적으로 인스턴스화할 수 없다.

요약 클래스와 믹스인은 Enum을 명시적으로 구현하거나 확장할 수 있지만 enum 선언에 의해 구현되거나 혼합되지 않는 한 어떤 객체도 해당 클래스 또는 믹스인의 유형을 실제로 구현할 수 없다.
- #### 간단한 enums 선언 (Declaring simple enums)

간단한 enums type을 선언하려면 enum 키워드를 사용하고 열거하려는 값을 나열다.

``` dart
enum Color { red, green, blue }
```
- TIP : 복사-붙여넣기 오류를 방지하기 위해 열거 유형을 선언할 때 후행 쉼표를 사용할 수도 있습니다.

- #### Declaring enhanced enums

### 참고 자료

- https://dart.dev/guides/language/language-tour 

